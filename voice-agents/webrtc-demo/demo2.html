<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Demo2 - Local and Remote Audio</title>
    <style>
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }

        .connected {
            background-color: #d4edda;
            color: #155724;
        }

        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }

        #messagesContainer {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            min-height: 200px;
            overflow-y: auto;
        }

        .message {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 4px;
        }

        .sent {
            background-color: #e3f2fd;
            /* text-align: right; */
        }

        .received {
            background-color: #f1f1f1;
            /* text-align: left; */
        }

        .message.debug {
            background-color: #f3c3c3;
            /* text-align: left; */
        }

        .zone {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .zone-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .zone-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <h1>WebRTC Demo2 <small style="color: #6c757d;">Local and Remote Audio</small>
    </h1>

    <div>
        <label for="roomId">Room ID: </label>
        <input type="text" id="roomId" value="test-room">
        <button id="connectBtn">[1] Connect to Room</button>
    </div>

    <div id="connectionStatus" class="status disconnected">Disconnected</div>

    <div>
        <div>
            Local:
            <div>
                <label for="audioSource">Audio input source: </label>
                <select id="audioSource"></select>
            </div>

            <audio id="localAudio" controls autoplay muted></audio>

        </div>
        <div>
            Remote:
            <audio id="remoteAudio" controls autoplay muted></audio>
        </div>
    </div>
    <hr>

    <div class="zone" id="controlZone">
        <div class="zone-header">
            <div>
                <span id="zoneStatus">Disabled - Connect to a room first</span>
            </div>
        </div>
        <div class="zone-content zone-disabled">
            <div>
                <h2>Local Side</h2>
                <button id="createOfferBtn">[2] Create offer</button>
            </div>

            <div>
                <h2>Remote Side</h2>
                <button id="createAnswerBtn">[3] Create answer</button>
            </div>
        </div>
    </div>

    <div>
        <h2>Messages</h2>
        <div id="messagesContainer"></div>
    </div>

</body>

<script>
    const localAudio = document.getElementById('localAudio');
    const remoteAudio = document.getElementById('remoteAudio');
    const audioSource = document.getElementById('audioSource');
    const createOfferBtn = document.getElementById('createOfferBtn');
    const createAnswerBtn = document.getElementById('createAnswerBtn');
    const connectBtn = document.getElementById('connectBtn');
    const roomIdInput = document.getElementById('roomId');
    const connectionStatus = document.getElementById('connectionStatus');
    const messagesContainer = document.getElementById('messagesContainer');
    const controlZone = document.getElementById('controlZone');
    const zoneStatus = document.getElementById('zoneStatus');

    const constraints = {
        audio: true,
        video: false
    };

    const configuration = {
        iceServers: [
            { urls: 'stun:stun.miwifi.com:3478' },
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
        ]
    }

    let localStream;
    let peerConnection;
    let ws;
    let receivedOffer = null; // Store the received offer

    // Function to toggle the zone based on connection status
    function setZoneState(enabled) {
        const zoneContent = controlZone.querySelector('.zone-content');
        if (enabled) {
            zoneContent.classList.remove('zone-disabled');
            zoneStatus.textContent = 'Enabled - Connected to room';
            // addMessageToList('Zone enabled', 'sent');
        } else {
            zoneContent.classList.add('zone-disabled');
            zoneStatus.textContent = 'Disabled - Connect to a room first';
            // addMessageToList('Zone disabled', 'sent');
        }
    }

    // Function to add message to the messages container
    function addMessageToList(message, type) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message', type);

        // Add timestamp
        const timestamp = new Date().toLocaleTimeString();

        // Format the message content
        const content = typeof message === 'object' ? JSON.stringify(message) : message;
        messageElement.textContent = `[${timestamp}] ${content}`;

        // messagesContainer.appendChild(messageElement);
        // messagesContainer.scrollTop = messagesContainer.scrollHeight;

        messagesContainer.prepend(messageElement); // <-- Changed this line
        messagesContainer.scrollTop = 0;
    }

    // Function to send signaling messages
    function sendSignalingMessage(message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            console.log('Sending message:', message);
            addMessageToList(message, 'sent');
            ws.send(JSON.stringify(message));
        } else {
            console.error('WebSocket not connected');
            connectionStatus.textContent = 'Not connected - message not sent';
            connectionStatus.className = 'status disconnected';
        }
    }

    // WebSocket connection
    function connectToRoom() {
        const roomId = roomIdInput.value;
        if (!roomId) {
            alert('Please enter a room ID');
            return;
        }

        ws = new WebSocket(`wss://sign.tinylink.dev/room/${roomId}`);

        ws.onopen = () => {
            console.log('WebSocket connected');
            connectionStatus.textContent = 'Connected';
            connectionStatus.className = 'status connected';
            addMessageToList('Connected to signaling server', 'received');
            setZoneState(true);
        };

        ws.onclose = () => {
            console.log('WebSocket disconnected');
            connectionStatus.textContent = 'Disconnected';
            connectionStatus.className = 'status disconnected';
            addMessageToList('Disconnected from signaling server', 'received');
            setZoneState(false);
        };

        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            connectionStatus.textContent = 'Connection Error';
            connectionStatus.className = 'status disconnected';
            addMessageToList('Connection error: ' + error, 'received');
            setZoneState(false);
        };

        ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            console.log('Received message:', message);
            addMessageToList(message, 'received');

            switch (message.type) {
                case 'offer':
                    receivedOffer = message.value; // Store the offer
                    // createAnswerBtn.disabled = false; // Enable the create answer button
                    addMessageToList('Received offer - Create Answer button enabled', 'received');
                    handleRemoteOffer(message.value);
                    break;
                case 'answer':
                    handleRemoteAnswer(message.value);
                    break;
                case 'candidate':
                    handleRemoteCandidate(message.value);
                    break;
            }
        };
    }

    // Function to populate the device selector
    async function populateDeviceList() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioDevices = devices.filter(device => device.kind === 'audioinput');

            audioSource.innerHTML = audioDevices.map(device =>
                `<option value="${device.deviceId}">${device.label || `Microphone ${audioSource.length + 1}`}</option>`
            ).join('');

            // If we have devices, start with the first one
            if (audioDevices.length > 0) {
                await startStream(audioDevices[0].deviceId);
            }
        } catch (err) {
            console.error('Error getting devices:', err);
        }
    }

    // Function to start/restart the stream with selected device
    async function startStream(deviceId) {
        // Stop any existing stream
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }

        // Start new stream with selected device
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: { deviceId: deviceId ? { exact: deviceId } : undefined },
                video: false
            });
            localAudio.srcObject = localStream;

            // If we already have an active connection, we need to replace the tracks
            if (peerConnection && peerConnection.connectionState !== 'closed') {
                const senders = peerConnection.getSenders();
                const audioSender = senders.find(sender => sender.track && sender.track.kind === 'audio');

                if (audioSender && localStream.getAudioTracks().length > 0) {
                    addMessageToList('Replacing audio track in active connection', 'debug');
                    audioSender.replaceTrack(localStream.getAudioTracks()[0])
                        .then(() => {
                            addMessageToList('Audio track replaced successfully', 'debug');
                        })
                        .catch(err => {
                            addMessageToList(`Error replacing audio track: ${err}`, 'debug');
                            console.error('Error replacing audio track:', err);
                        });
                }
            }
        } catch (err) {
            console.error('Error accessing media devices:', err);
            addMessageToList(`Error accessing media device: ${err}`, 'debug');
        }
    }

    function createPeerConnection() {
        peerConnection = new RTCPeerConnection(configuration);

        if (localStream) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
        }

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('ICE candidate:', event.candidate);
                sendSignalingMessage({
                    type: 'candidate',
                    value: event.candidate
                });
            }
        }

        peerConnection.ontrack = (event) => {
            console.log('Track added:', event.track);
            addMessageToList(`Track added: ${event.track.id}`, 'debug');

            if (remoteAudio.srcObject !== event.streams[0]) {
                remoteAudio.srcObject = event.streams[0];
                addMessageToList('Remote audio source set', 'debug');
            }
        }
    }

    function createOffer() {
        peerConnection.createOffer().then(offer => {
            return peerConnection.setLocalDescription(offer);
        }).then(() => {
            sendSignalingMessage({
                type: 'offer',
                value: peerConnection.localDescription
            });
        }).catch(err => {
            console.error('Error creating offer:', err);
        });
    }

    function handleRemoteOffer(offerData) {
        if (!peerConnection) {
            createPeerConnection();
        }

        const offer = new RTCSessionDescription(offerData);
        peerConnection
            .setRemoteDescription(offer);
        // .then(() => peerConnection.createAnswer())
        // .then(answer => peerConnection.setLocalDescription(answer))
        // .then(() => {
        //     sendSignalingMessage({
        //         type: 'answer',
        //         value: peerConnection.localDescription
        //     });
        // })
        // .catch(err => {
        //     console.error('Error creating answer:', err);
        // });
    }

    function handleRemoteAnswer(answerData) {
        const answer = new RTCSessionDescription(answerData);
        peerConnection
            .setRemoteDescription(answer)
            .then(() => {
                console.log('Remote description set successfully');
                addMessageToList('Remote description set successfully', 'debug');
            })
            .catch(err => {
                console.error('Error setting remote description:', err);
            });
    }

    function handleRemoteCandidate(candidate) {
        if (!peerConnection) {
            createPeerConnection();
        }

        if (peerConnection) {
            peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
                .then(() => {
                    console.log('ICE candidate added successfully');
                    addMessageToList(
                        `ICE candidate added successfully.`, 'debug');
                })
                .catch(err => {
                    console.error('Error adding ICE candidate:', err);
                });
        } else {
            addMessageToList('No peer connection found', 'debug');
        }
    }

    // Event Listeners
    audioSource.addEventListener('change', () => {
        startStream(audioSource.value);
    });

    createOfferBtn.addEventListener('click', () => {
        createPeerConnection();
        createOffer();
    });

    createAnswerBtn.addEventListener('click', () => {
        if (!receivedOffer) {
            addMessageToList('No offer received yet', 'sent');
            return;
        }

        if (!peerConnection) {
            createPeerConnection();
        }

        const offer = new RTCSessionDescription(receivedOffer);
        peerConnection
            .setRemoteDescription(offer)
            .then(() => peerConnection.createAnswer())
            .then(answer => peerConnection.setLocalDescription(answer))
            .then(() => {
                sendSignalingMessage({
                    type: 'answer',
                    value: peerConnection.localDescription
                });
            })
            .catch(err => {
                console.error('Error creating answer:', err);
            });

        // createAnswerBtn.disabled = true; // Disable the button after sending answer
    });

    connectBtn.addEventListener('click', connectToRoom);

    // Initial setup
    populateDeviceList();
    setZoneState(false); // Initially disable the zone
</script>

</html>